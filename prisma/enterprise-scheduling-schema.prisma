// Enterprise-Grade Scheduling Schema
// Extends existing appointment system with robust scheduling capabilities

// ============================================================================
// ENUMS
// ============================================================================

enum ScheduleStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  ARCHIVED
}

enum TimeSlotStatus {
  AVAILABLE
  BOOKED
  BLOCKED
  MAINTENANCE
  EMERGENCY_ONLY
}

enum ScheduleType {
  REGULAR
  EMERGENCY
  ON_CALL
  CONSULTATION
  PROCEDURE
  FOLLOW_UP
}

enum RecurrencePattern {
  NONE
  DAILY
  WEEKLY
  BIWEEKLY
  MONTHLY
  CUSTOM
}

enum ConflictResolutionStrategy {
  PREVENT_BOOKING
  AUTO_RESCHEDULE
  MANUAL_REVIEW
  OVERRIDE_ALLOWED
}

enum AvailabilityOverrideType {
  EMERGENCY_UNAVAILABLE
  EXTENDED_HOURS
  REDUCED_HOURS
  BREAK_TIME
  PERSONAL_LEAVE
  MEDICAL_LEAVE
  TRAINING
  CONFERENCE
  VACATION
}

// ============================================================================
// CORE SCHEDULING MODELS
// ============================================================================

model DoctorSchedule {
  id                String        @id @default(cuid())
  doctor_id         String
  name              String        // e.g., "Regular Schedule", "Emergency Coverage"
  description       String?
  schedule_type     ScheduleType  @default(REGULAR)
  status            ScheduleStatus @default(ACTIVE)
  is_default        Boolean       @default(false)
  timezone          String        @default("UTC")
  
  // Schedule validity period
  effective_from    DateTime      @default(now())
  effective_until   DateTime?
  
  // Auto-scheduling settings
  auto_accept_bookings Boolean    @default(true)
  require_confirmation Boolean    @default(false)
  max_advance_booking_days Int    @default(30)
  min_advance_booking_hours Int   @default(2)
  
  // Conflict resolution
  conflict_resolution ConflictResolutionStrategy @default(PREVENT_BOOKING)
  
  // Metadata
  metadata          Json?
  
  // Relations
  doctor            Doctor        @relation(fields: [doctor_id], references: [id], onDelete: Cascade)
  schedule_templates ScheduleTemplate[]
  schedule_blocks   ScheduleBlock[]
  time_slots        TimeSlot[]
  availability_overrides AvailabilityOverride[]
  
  created_at        DateTime      @default(now())
  updated_at        DateTime      @updatedAt
  
  @@map("doctor_schedules")
  @@index([doctor_id, status])
  @@index([effective_from, effective_until])
}

model ScheduleTemplate {
  id                String        @id @default(cuid())
  schedule_id       String
  name              String        // e.g., "Monday Morning", "Weekend Emergency"
  day_of_week       Int           // 0 = Sunday, 1 = Monday, etc.
  start_time        String        // "09:00"
  end_time          String        // "17:00"
  is_working        Boolean       @default(true)
  
  // Break configuration
  break_start       String?       // "12:00"
  break_end         String?       // "13:00"
  break_duration    Int?          // minutes
  
  // Appointment settings
  appointment_duration Int        @default(30) // minutes
  buffer_time       Int           @default(15) // minutes between appointments
  max_appointments  Int?          // Maximum appointments per day
  
  // Recurrence settings
  recurrence_pattern RecurrencePattern @default(NONE)
  recurrence_end_date DateTime?
  recurrence_interval Int?        // For custom patterns
  
  // Special settings
  is_emergency_only Boolean       @default(false)
  requires_approval Boolean       @default(false)
  
  // Relations
  schedule          DoctorSchedule @relation(fields: [schedule_id], references: [id], onDelete: Cascade)
  schedule_blocks   ScheduleBlock[]
  
  created_at        DateTime      @default(now())
  updated_at        DateTime      @updatedAt
  
  @@map("schedule_templates")
  @@unique([schedule_id, day_of_week, start_time])
  @@index([day_of_week, is_working])
}

model ScheduleBlock {
  id                String        @id @default(cuid())
  schedule_id       String
  template_id       String?
  date              DateTime      // Specific date for this block
  start_time        String        // "09:00"
  end_time          String        // "17:00"
  is_working        Boolean       @default(true)
  
  // Break configuration
  break_start       String?       // "12:00"
  break_end         String?       // "13:00"
  
  // Appointment settings
  appointment_duration Int        @default(30)
  buffer_time       Int           @default(15)
  max_appointments  Int?
  
  // Status and notes
  status            ScheduleStatus @default(ACTIVE)
  notes             String?
  is_recurring      Boolean       @default(false)
  
  // Relations
  schedule          DoctorSchedule @relation(fields: [schedule_id], references: [id], onDelete: Cascade)
  template          ScheduleTemplate? @relation(fields: [template_id], references: [id], onDelete: SetNull)
  time_slots        TimeSlot[]
  appointments      Appointment[]
  
  created_at        DateTime      @default(now())
  updated_at        DateTime      @updatedAt
  
  @@map("schedule_blocks")
  @@unique([schedule_id, date])
  @@index([date, is_working])
}

model TimeSlot {
  id                String        @id @default(cuid())
  schedule_id       String
  block_id          String?
  date              DateTime      // Date of the slot
  start_time        String        // "09:00"
  end_time          String        // "09:30"
  duration_minutes  Int           @default(30)
  
  // Slot status
  status            TimeSlotStatus @default(AVAILABLE)
  is_available      Boolean       @default(true)
  is_booked         Boolean       @default(false)
  
  // Booking information
  appointment_id    Int?          // Link to appointment if booked
  booked_at         DateTime?
  booked_by         String?       // User who booked the slot
  
  // Special settings
  is_emergency_only Boolean       @default(false)
  requires_approval Boolean       @default(false)
  max_duration      Int?          // Maximum appointment duration for this slot
  
  // Metadata
  metadata          Json?
  
  // Relations
  schedule          DoctorSchedule @relation(fields: [schedule_id], references: [id], onDelete: Cascade)
  block             ScheduleBlock? @relation(fields: [block_id], references: [id], onDelete: Cascade)
  appointment       Appointment? @relation(fields: [appointment_id], references: [id], onDelete: SetNull)
  
  created_at        DateTime      @default(now())
  updated_at        DateTime      @updatedAt
  
  @@map("time_slots")
  @@unique([schedule_id, date, start_time])
  @@index([date, status, is_available])
  @@index([appointment_id])
}

model AvailabilityOverride {
  id                String        @id @default(cuid())
  doctor_id         String
  schedule_id       String?
  override_type     AvailabilityOverrideType
  title             String
  description       String?
  
  // Time period
  start_date        DateTime
  end_date          DateTime
  start_time        String?       // Override specific time if needed
  end_time          String?
  
  // Override settings
  is_available      Boolean       @default(false)
  max_appointments  Int?
  appointment_duration Int?
  buffer_time       Int?
  
  // Approval workflow
  is_approved       Boolean       @default(false)
  approved_by       String?
  approved_at       DateTime?
  approval_notes    String?
  
  // Relations
  doctor            Doctor        @relation(fields: [doctor_id], references: [id], onDelete: Cascade)
  schedule          DoctorSchedule? @relation(fields: [schedule_id], references: [id], onDelete: SetNull)
  
  created_at        DateTime      @default(now())
  updated_at        DateTime      @updatedAt
  
  @@map("availability_overrides")
  @@index([doctor_id, start_date, end_date])
  @@index([is_approved])
}

// ============================================================================
// CONFLICT MANAGEMENT
// ============================================================================

model SchedulingConflict {
  id                String        @id @default(cuid())
  appointment_id    Int?
  schedule_id       String?
  conflict_type     String        // "DOUBLE_BOOKING", "OUTSIDE_HOURS", "DOCTOR_UNAVAILABLE"
  conflict_reason   String
  severity          String        @default("MEDIUM") // "LOW", "MEDIUM", "HIGH", "CRITICAL"
  
  // Conflict details
  conflicting_start DateTime
  conflicting_end   DateTime
  conflicting_appointment_id Int?
  
  // Resolution
  is_resolved       Boolean       @default(false)
  resolution_strategy String?     // "AUTO_RESCHEDULE", "MANUAL_REVIEW", "OVERRIDE"
  resolved_by       String?
  resolved_at       DateTime?
  resolution_notes  String?
  
  // Relations
  appointment       Appointment? @relation(fields: [appointment_id], references: [id], onDelete: Cascade)
  schedule          DoctorSchedule? @relation(fields: [schedule_id], references: [id], onDelete: Cascade)
  
  created_at        DateTime      @default(now())
  updated_at        DateTime      @updatedAt
  
  @@map("scheduling_conflicts")
  @@index([is_resolved, severity])
  @@index([conflicting_start, conflicting_end])
}

// ============================================================================
// SCHEDULING ANALYTICS
// ============================================================================

model SchedulingMetrics {
  id                String        @id @default(cuid())
  doctor_id         String
  date              DateTime      // Date for the metrics
  schedule_id       String?
  
  // Availability metrics
  total_slots       Int           @default(0)
  available_slots   Int           @default(0)
  booked_slots      Int           @default(0)
  blocked_slots     Int           @default(0)
  
  // Utilization metrics
  utilization_rate  Decimal       @db.Decimal(5, 2) // Percentage
  no_show_rate      Decimal       @db.Decimal(5, 2) // Percentage
  cancellation_rate Decimal       @db.Decimal(5, 2) // Percentage
  
  // Time metrics
  total_working_hours Decimal     @db.Decimal(5, 2)
  total_break_hours   Decimal     @db.Decimal(5, 2)
  overtime_hours      Decimal     @db.Decimal(5, 2)
  
  // Revenue metrics (if applicable)
  total_revenue     Decimal?      @db.Decimal(10, 2)
  average_appointment_value Decimal? @db.Decimal(10, 2)
  
  // Relations
  doctor            Doctor        @relation(fields: [doctor_id], references: [id], onDelete: Cascade)
  schedule          DoctorSchedule? @relation(fields: [schedule_id], references: [id], onDelete: SetNull)
  
  created_at        DateTime      @default(now())
  updated_at        DateTime      @updatedAt
  
  @@map("scheduling_metrics")
  @@unique([doctor_id, date])
  @@index([date, utilization_rate])
}

// ============================================================================
// SCHEDULING NOTIFICATIONS
// ============================================================================

model SchedulingNotification {
  id                String        @id @default(cuid())
  doctor_id         String
  appointment_id    Int?
  schedule_id       String?
  
  // Notification details
  type              String        // "SCHEDULE_CHANGE", "CONFLICT_ALERT", "AVAILABILITY_UPDATE"
  title             String
  message           String
  priority          String        @default("MEDIUM") // "LOW", "MEDIUM", "HIGH", "URGENT"
  
  // Delivery settings
  channels          String[]      // ["EMAIL", "SMS", "IN_APP", "PUSH"]
  scheduled_for     DateTime?
  is_sent           Boolean       @default(false)
  sent_at           DateTime?
  
  // Recipients
  recipient_emails  String[]
  recipient_phones  String[]
  
  // Relations
  doctor            Doctor        @relation(fields: [doctor_id], references: [id], onDelete: Cascade)
  appointment       Appointment? @relation(fields: [appointment_id], references: [id], onDelete: Cascade)
  schedule          DoctorSchedule? @relation(fields: [schedule_id], references: [id], onDelete: Cascade)
  
  created_at        DateTime      @default(now())
  updated_at        DateTime      @updatedAt
  
  @@map("scheduling_notifications")
  @@index([is_sent, scheduled_for])
  @@index([doctor_id, type])
}

// ============================================================================
// UPDATE EXISTING MODELS
// ============================================================================

// Add to existing Doctor model
model Doctor {
  // ... existing fields ...
  
  // New scheduling relations
  schedules         DoctorSchedule[]
  availability_overrides AvailabilityOverride[]
  scheduling_conflicts SchedulingConflict[]
  scheduling_metrics SchedulingMetrics[]
  scheduling_notifications SchedulingNotification[]
}

// Add to existing Appointment model
model Appointment {
  // ... existing fields ...
  
  // New scheduling relations
  schedule_block    ScheduleBlock? @relation(fields: [schedule_block_id], references: [id], onDelete: SetNull)
  time_slot         TimeSlot? @relation(fields: [time_slot_id], references: [id], onDelete: SetNull)
  scheduling_conflicts SchedulingConflict[]
  scheduling_notifications SchedulingNotification[]
  
  // New fields
  schedule_block_id String?
  time_slot_id      String?
  booking_source    String?       // "WEB", "MOBILE", "ADMIN", "API"
  confirmation_required Boolean   @default(false)
  confirmed_at      DateTime?
  no_show_reason   String?
}

